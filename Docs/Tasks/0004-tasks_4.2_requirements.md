Below is a **concept-only** implementation plan that builds directly on your uploaded `UFCExpeditionManager` / `UFCExpeditionData` and the (earlier) “exploration texture + per-cell updates” approach — but adapted to your **16×16 grid** with **16×16 subgrid per area** (so **256×256 global subcells**).

---
## Implementation Checklist (Task 4.2)

1. Hook WBP_WorldMap into UFCExpeditionManager (UI integration).
2. Author and configure the 256x256 land mask texture.
3. Feed overworld positions into WorldMap_RecordVisitedWorldLocation.


# Concept Week 4: World Map Planning + Exploration (16×16 areas, 16×16 subcells)

## 0) Targets you listed (interpreted as concrete rules)

- **Area IDs** count from **bottom-left = 0**, left→right then bottom→top.
- **Starting revealed at a new game:**

  - Areas **0–15** (bottom row) fully revealed
  - Areas **16, 17, 30, 31** fully revealed

- **One start point (for now):** `StartPointID = 24`, `SubId = 26`
- Selecting **GridId 24** triggers:

  - Determine a **route preview target**: `GridId 25`, `SubId 10` (your known “nearest unrevealed land-eligible target”)
  - Compute **shortest path** from the **office** cell `GridId 8, SubId 0` to that target
  - **Paint** the route **one subcell at a time in red**
  - **Compute costs** per subcell along the route using:

    - Risk:

      - water revealed = 2
      - water unrevealed = 3
      - land revealed = 1

    - Money cost:

      - water = 3 gold
      - land = 1 gold

> Note: you did not define “land unrevealed” risk. The cleanest constraint is: **pathfinding only traverses revealed nodes**, except the **final target node**, which is allowed if it’s land. That makes the risk rules complete.

---

## 1) Coordinate systems (the key to “bottom-left = 0”)

### Area (main grid) indexing

Let:

- `GridW = 16`, `GridH = 16`

**AreaID from bottom-left:**

- `AreaID = X + Y * GridW`
- `X ∈ [0..15]` left→right
- `Y ∈ [0..15]` bottom→top

**Decode:**

- `X = AreaID % 16`
- `Y = AreaID / 16`

### Subcell indexing inside an area

Let:

- `SubW = 16`, `SubH = 16`

**SubId from bottom-left inside the area:**

- `SubId = SX + SY * SubW`
- `SX ∈ [0..15]`, `SY ∈ [0..15]` bottom→top

### Global subcell indexing across the whole map

Define one global 256×256 grid:

- `GlobalW = GridW * SubW = 256`
- `GlobalH = GridH * SubH = 256`

Convert (AreaID, SubId) to global subcell coords:

- `AreaX = AreaID % 16`
- `AreaY = AreaID / 16`
- `SubX = SubId % 16`
- `SubY = SubId / 16`
- `GlobalX = AreaX * 16 + SubX`
- `GlobalY = AreaY * 16 + SubY`

Global flat index:

- `GlobalId = GlobalX + GlobalY * 256`

### UI mapping (top-left origin)

UMG is top-left origin, so for drawing:

- `UI_Y = (GlobalH - 1) - GlobalY`
- `UI_X = GlobalX`

Same for areas:

- `AreaUI_Y = (GridH - 1) - AreaY`

---

## 2) Ownership & where the new state lives (using your uploaded classes)

Your uploaded subsystem is a perfect “always available” home:

### Extend `UFCExpeditionManager` (GameInstanceSubsystem)

Add these responsibilities:

1. Hold / load / save world map exploration state
2. Expose planning API to UI:

   - select area/startpoint
   - compute preview route + costs
   - provide textures for Fog + Route overlays

### Extend `UFCExpeditionData` (UObject)

Use it to store **planning selection + computed result**:

- Selected GridId / StartPointId / chosen SubId
- Route result:

  - `TArray<int32> RouteGlobalIds` or `TArray<FIntPoint>` global coords

- Cost result:

  - `int32 MoneyCost`
  - `int32 RiskCost`

This matches your current lifecycle: planning → in-progress → complete/failed.

---

## 3) “Explored / Revealed” storage & initial reveal rules

### Data representation

You need **real-time updates** and persistence. Don’t use a DataTable for runtime writes.

Use:

- **In-memory:** `TBitArray<>` or `TArray<uint8>` (size = 256×256 = 65536)

  - `0 = unrevealed`
  - `1 = revealed`

- **Persist:** `USaveGame` (recommended) or JSON (optional debug/export)

  - SaveGame is safe and async; JSON is fine too but you’ll want throttling.

### New-game initialization

When no save exists:

- Set all bits 0
- Fully reveal:

  - areas 0–15
  - areas 16, 17, 30, 31
    Meaning: for each area, mark all its 16×16 subcells as revealed in the global bitset.

---

## 4) Terrain (land vs water) source of truth

Cost rules require knowing if each subcell is **water or land**.

You need a “landmask” at **256×256** resolution aligned to your map:

- `LandMask[GlobalId] = 1 land, 0 water`

Options:

1. **Author a 256×256 grayscale texture** (PF_G8) where white=land
2. A custom binary asset / CSV baked from your map

At runtime, load it into a CPU array once.

---

## 5) Planning flow for your current special case

### Constants for week/test build

- Office start: `(GridId 8, SubId 0)`
- Current selectable startpoint: `(GridId 24, SubId 26)`
- Preview target (frontier): `(GridId 25, SubId 10)` _(hardcoded for now as you stated)_

### What happens when player selects GridId 24

1. Validate selection is 24
2. Compute:

   - `StartGlobal = GlobalId(Grid 8, Sub 0)`
   - `GoalGlobal = GlobalId(Grid 25, Sub 10)`

3. Run shortest path on **global 256×256**:

   - 4-neighbor (N,S,E,W) recommended to keep routes clean
   - Passability rules (for now):

     - You may traverse **revealed** cells freely (water/land)
     - You may traverse **unrevealed water**? (your rules include “water unrevealed” risk, so allow it if you want)
     - You may traverse **unrevealed land** only if it’s the **goal** (so risk rules remain complete)

4. Store route as global ids list
5. Compute costs over the route (per subcell, likely excluding the origin cell):

   - Determine `IsLand(GlobalId)` via landmask
   - Determine `IsRevealed(GlobalId)` via explored bitset
   - Risk:

     - if water:

       - revealed → +2
       - unrevealed → +3

     - if land:

       - (only revealed on the path under the constraint) → +1

   - Money:

     - water → +3
     - land → +1

6. Route visualization:

   - Clear route overlay texture
   - Start a timer that “paints” the next node each tick (see section 6)

---

## 6) Route painting (red, one subcell after another)

Use the same “mask texture” concept as fog-of-war, but for route:

- `RouteTexture` is a 256×256 PF_G8

  - 0 = no route
  - 255 = route pixel

UI material `M_RouteOverlay`:

- Sample `RouteTexture.R`
- Output `Red` with alpha = pixel value (optionally scaled)

Painting:

- Each tick:

  - take next `GlobalId` from `RouteGlobalIds`
  - set `RouteTexture[GlobalId] = 255`
  - update just that 1×1 region

- When finished, stop timer

This gives you the “marching ants” feel without complex spline drawing.

---

## 7) Cost calculation “to the starting point” vs “to the frontier”

Your prompt mixes “start point” and “nearest not revealed land cell”. To keep this deterministic:

- **Preview route & preview costs:** office → frontier target `(25,10)` (what you asked for explicitly)
- Later you can also compute:

  - office → actual startpoint cell `(24,26)`
  - OR frontier → startpoint (if you require “must reach land entry first”)

But for now, enforce the exact stated behavior: compute + paint route to `(25,10)` and compute costs on that path.

---

## 8) Overworld tracking: mapping world position → (AreaID, SubId)

You need a stable mapping between your overworld worldspace and the 256×256 global subgrid.

### Define map bounds

Create a simple config struct (in data asset or in subsystem):

- `WorldMin` (FVector2D) and `WorldMax` (FVector2D) for the playable overworld rectangle representing the whole map.

### Convert position to global subcell

Given pawn world position `(X,Y)`:

- `u = (X - WorldMin.X) / (WorldMax.X - WorldMin.X)` clamped 0..1
- `v = (Y - WorldMin.Y) / (WorldMax.Y - WorldMin.Y)` clamped 0..1
- `GlobalX = floor(u * 256)`
- `GlobalY = floor(v * 256)`

(Adjust axis/sign if your overworld uses a different orientation; but keep the math centralized in one function so you can fix it once.)

Then:

- `GlobalId = GlobalX + GlobalY * 256`
- Mark explored bitset for that GlobalId

### “Every subgrid cell visited gets revealed”

- On movement update (tick or distance-based):

  - Determine current global cell
  - If not revealed → set revealed and mark “dirty”

---

## 9) Real-time persistence (SaveGame or JSON)

### Why not DataTables

UE DataTables are **not** designed for runtime writing as save-state.

### Recommended pipeline

- Maintain in-memory `ExploredBitset`
- Track `bExplorationDirty`
- Autosave that state periodically (e.g. every 0.5–2 seconds) or on map close:

  - SaveGame slot: `"WorldMapExploration"`
  - Store:

    - a packed byte array of 65536 bits (or uint8 per cell if simplicity beats size)

Optional:

- Also export JSON for debugging and quick inspection (throttled).

---

## 10) API surface between UI and subsystem (what WBP_WorldMap calls)

Expose BlueprintCallable functions on `UFCExpeditionManager` (or a dedicated `UFCWorldMapSubsystem`, but you can keep it in the same subsystem for now):

**Selection / planning**

- `SelectGrid(int32 GridId)` -> validates selection, assigns planning state
- `GetAvailableStartPointsForGrid(int32 GridId)` -> currently returns only `(24,26)`
- `ComputePreviewRouteForSelection()` -> returns route + costs

**Exploration**

- `IsRevealed_Global(int32 GlobalId)`
- `IsRevealed(int32 GridId, int32 SubId)`
- `GetFogTexture()` (global 256×256) or per-area if you prefer
- `GetRouteTexture()` (global 256×256)

**Overworld**

- `UpdateExplorationFromWorldPos(FVector WorldPos)` -> marks revealed

---

## 11) Concrete sanity checks with your given numbers

- GridId 24:

  - `X=24%16=8`, `Y=24/16=1` ✅ second row from bottom, column 8

- StartPoint subId 26:

  - `SX=10`, `SY=1` ✅

- Office: Grid 8 sub 0:

  - Grid 8: X=8, Y=0 ✅ bottom row center-ish

This lines up nicely with your “office bottom center” idea.

CODE SNIPPETS

Alright — here’s a **clean, compile-friendly set of code changes** that **extends your uploaded** `UFCExpeditionManager / UFCExpeditionData` (they’re currently a simple GI subsystem + data object ), and adds a small **WorldMapExploration** module (bitset-ish mask + landmask + shortest-path BFS).

> Notes:
>
> - I’m using **global 256×256 subcells** (16×16 areas × 16×16 subcells).
> - Pathfinding uses **BFS** (shortest in steps) which is perfect here because every move cost is “1 cell”.
> - “Landmask” is loaded from an optional 256×256 `UTexture2D` (white=land). If not provided, it defaults to “all land”.

---

## 1) NEW FILES — WorldMapExploration module

### `Source/FC/WorldMap/FCWorldMapExploration.h`

```cpp
// Copyright Iron Anchor Interactive. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"

/**
 * Pure C++ helper (no UObject) for:
 * - coordinate conversion (GridId/SubId <-> global 256x256 cell)
 * - revealed mask storage (0/255 byte per global cell)
 * - land mask storage (0/1 per global cell)
 * - shortest path search (BFS)
 */
class FFCWorldMapExploration
{
public:
	static constexpr int32 GridSize = 16;     // 16x16 areas
	static constexpr int32 SubSize  = 16;     // 16x16 subcells per area
	static constexpr int32 GlobalSize = GridSize * SubSize; // 256
	static constexpr int32 GlobalCount = GlobalSize * GlobalSize; // 65536

	FFCWorldMapExploration();

	// --- Reveal Mask (0 = hidden, 255 = revealed) ---
	const TArray<uint8>& GetRevealMask() const { return RevealMask; }
	TArray<uint8>& GetRevealMaskMutable() { return RevealMask; }

	bool IsRevealed_Global(int32 GlobalId) const;
	bool SetRevealed_Global(int32 GlobalId, bool bRevealed);

	// --- Land mask (0 = water, 1 = land) ---
	const TArray<uint8>& GetLandMask() const { return LandMask; }
	void SetLandMask(const TArray<uint8>& InLandMask);

	bool IsLand_Global(int32 GlobalId) const;
	bool IsWater_Global(int32 GlobalId) const { return !IsLand_Global(GlobalId); }

	// --- Coordinate conversion ---
	static bool IsValidGridId(int32 GridId);
	static bool IsValidSubId(int32 SubId);
	static bool IsValidGlobal(int32 X, int32 Y);
	static bool IsValidGlobalId(int32 GlobalId);

	static void GridIdToXY(int32 GridId, int32& OutX, int32& OutY); // bottom-left origin
	static int32 XYToGridId(int32 X, int32 Y);                     // bottom-left origin

	static void SubIdToXY(int32 SubId, int32& OutSX, int32& OutSY); // bottom-left origin
	static int32 XYToSubId(int32 SX, int32 SY);                    // bottom-left origin

	static int32 AreaSubToGlobalId(int32 GridId, int32 SubId);
	static void GlobalIdToAreaSub(int32 GlobalId, int32& OutGridId, int32& OutSubId);

	static void GlobalIdToXY(int32 GlobalId, int32& OutGX, int32& OutGY);
	static int32 XYToGlobalId(int32 GX, int32 GY);

	// --- Initialization rules ---
	void ApplyDefaultRevealedAreas_NewGame();

	// --- Pathfinding ---
	// Shortest route in steps. Movement: 4-neighbors.
	// Traversal rule:
	//   - Water: traversable (revealed or not)
	//   - Land: traversable ONLY if revealed, except the Goal can be land even if unrevealed
	bool FindShortestPath_BFS(int32 StartGlobalId, int32 GoalGlobalId, TArray<int32>& OutPath) const;

private:
	bool IsTraversable_Global(int32 GlobalId, int32 GoalGlobalId) const;

	TArray<uint8> RevealMask; // size GlobalCount, values 0/255
	TArray<uint8> LandMask;   // size GlobalCount, values 0/1
};
```

### `Source/FC/WorldMap/FCWorldMapExploration.cpp`

```cpp
// Copyright Iron Anchor Interactive. All Rights Reserved.

#include "WorldMap/FCWorldMapExploration.h"
#include "Containers/Queue.h"
#include "Algo/Reverse.h"

FFCWorldMapExploration::FFCWorldMapExploration()
{
	RevealMask.Init(0, GlobalCount);
	LandMask.Init(1, GlobalCount); // default: all land
}

bool FFCWorldMapExploration::IsValidGridId(int32 GridId)
{
	return GridId >= 0 && GridId < (GridSize * GridSize);
}

bool FFCWorldMapExploration::IsValidSubId(int32 SubId)
{
	return SubId >= 0 && SubId < (SubSize * SubSize);
}

bool FFCWorldMapExploration::IsValidGlobal(int32 X, int32 Y)
{
	return X >= 0 && X < GlobalSize && Y >= 0 && Y < GlobalSize;
}

bool FFCWorldMapExploration::IsValidGlobalId(int32 GlobalId)
{
	return GlobalId >= 0 && GlobalId < GlobalCount;
}

void FFCWorldMapExploration::GridIdToXY(int32 GridId, int32& OutX, int32& OutY)
{
	OutX = GridId % GridSize;
	OutY = GridId / GridSize;
}

int32 FFCWorldMapExploration::XYToGridId(int32 X, int32 Y)
{
	return X + (Y * GridSize);
}

void FFCWorldMapExploration::SubIdToXY(int32 SubId, int32& OutSX, int32& OutSY)
{
	OutSX = SubId % SubSize;
	OutSY = SubId / SubSize;
}

int32 FFCWorldMapExploration::XYToSubId(int32 SX, int32 SY)
{
	return SX + (SY * SubSize);
}

int32 FFCWorldMapExploration::XYToGlobalId(int32 GX, int32 GY)
{
	return GX + (GY * GlobalSize);
}

void FFCWorldMapExploration::GlobalIdToXY(int32 GlobalId, int32& OutGX, int32& OutGY)
{
	OutGX = GlobalId % GlobalSize;
	OutGY = GlobalId / GlobalSize;
}

int32 FFCWorldMapExploration::AreaSubToGlobalId(int32 GridId, int32 SubId)
{
	int32 AX, AY; GridIdToXY(GridId, AX, AY);
	int32 SX, SY; SubIdToXY(SubId, SX, SY);

	const int32 GX = AX * SubSize + SX;
	const int32 GY = AY * SubSize + SY;
	return XYToGlobalId(GX, GY);
}

void FFCWorldMapExploration::GlobalIdToAreaSub(int32 GlobalId, int32& OutGridId, int32& OutSubId)
{
	int32 GX, GY; GlobalIdToXY(GlobalId, GX, GY);

	const int32 AX = GX / SubSize;
	const int32 AY = GY / SubSize;
	const int32 SX = GX % SubSize;
	const int32 SY = GY % SubSize;

	OutGridId = XYToGridId(AX, AY);
	OutSubId = XYToSubId(SX, SY);
}

bool FFCWorldMapExploration::IsRevealed_Global(int32 GlobalId) const
{
	if (!IsValidGlobalId(GlobalId)) return false;
	return RevealMask[GlobalId] >= 128;
}

bool FFCWorldMapExploration::SetRevealed_Global(int32 GlobalId, bool bRevealed)
{
	if (!IsValidGlobalId(GlobalId)) return false;

	const uint8 NewValue = bRevealed ? 255 : 0;
	if (RevealMask[GlobalId] == NewValue) return false;

	RevealMask[GlobalId] = NewValue;
	return true;
}

void FFCWorldMapExploration::SetLandMask(const TArray<uint8>& InLandMask)
{
	if (InLandMask.Num() == GlobalCount)
	{
		LandMask = InLandMask;
	}
}

bool FFCWorldMapExploration::IsLand_Global(int32 GlobalId) const
{
	if (!IsValidGlobalId(GlobalId)) return false;
	return LandMask[GlobalId] != 0;
}

void FFCWorldMapExploration::ApplyDefaultRevealedAreas_NewGame()
{
	// Reveal all subcells in: bottom row (0..15), plus 16,17,30,31.
	auto RevealAreaFully = [this](int32 GridId)
	{
		int32 AX, AY; GridIdToXY(GridId, AX, AY);
		for (int32 SY = 0; SY < SubSize; ++SY)
		{
			for (int32 SX = 0; SX < SubSize; ++SX)
			{
				const int32 GX = AX * SubSize + SX;
				const int32 GY = AY * SubSize + SY;
				const int32 GlobalId = XYToGlobalId(GX, GY);
				SetRevealed_Global(GlobalId, true);
			}
		}
	};

	for (int32 GridId = 0; GridId <= 15; ++GridId)
	{
		RevealAreaFully(GridId);
	}

	RevealAreaFully(16);
	RevealAreaFully(17);
	RevealAreaFully(30);
	RevealAreaFully(31);
}

bool FFCWorldMapExploration::IsTraversable_Global(int32 GlobalId, int32 GoalGlobalId) const
{
	if (!IsValidGlobalId(GlobalId)) return false;

	// Goal is allowed if it's land even when unrevealed (your "frontier land cell" case)
	if (GlobalId == GoalGlobalId)
	{
		return IsLand_Global(GlobalId);
	}

	// Water can be crossed even if unrevealed (risk rules include "water unrevealed")
	if (IsWater_Global(GlobalId))
	{
		return true;
	}

	// Land: only if revealed (risk rules for unrevealed land not defined yet)
	return IsRevealed_Global(GlobalId);
}

bool FFCWorldMapExploration::FindShortestPath_BFS(int32 StartGlobalId, int32 GoalGlobalId, TArray<int32>& OutPath) const
{
	OutPath.Reset();

	if (!IsValidGlobalId(StartGlobalId) || !IsValidGlobalId(GoalGlobalId))
	{
		return false;
	}

	if (!IsTraversable_Global(StartGlobalId, GoalGlobalId))
	{
		return false;
	}

	// BFS
	TArray<int32> CameFrom;
	CameFrom.Init(-1, GlobalCount);

	TQueue<int32> Q;
	Q.Enqueue(StartGlobalId);
	CameFrom[StartGlobalId] = StartGlobalId;

	bool bFound = false;

	while (!Q.IsEmpty())
	{
		int32 Current;
		Q.Dequeue(Current);

		if (Current == GoalGlobalId)
		{
			bFound = true;
			break;
		}

		int32 X, Y; GlobalIdToXY(Current, X, Y);

		const int32 NX[4] = { X + 1, X - 1, X,     X };
		const int32 NY[4] = { Y,     Y,     Y + 1, Y - 1 };

		for (int32 i = 0; i < 4; ++i)
		{
			if (!IsValidGlobal(NX[i], NY[i])) continue;

			const int32 NextId = XYToGlobalId(NX[i], NY[i]);
			if (CameFrom[NextId] != -1) continue; // visited

			if (!IsTraversable_Global(NextId, GoalGlobalId)) continue;

			CameFrom[NextId] = Current;
			Q.Enqueue(NextId);
		}
	}

	if (!bFound)
	{
		return false;
	}

	// Reconstruct path
	int32 Node = GoalGlobalId;
	while (Node != StartGlobalId)
	{
		OutPath.Add(Node);
		Node = CameFrom[Node];
		if (Node == -1) return false;
	}
	OutPath.Add(StartGlobalId);

	Algo::Reverse(OutPath);
	return true;
}
```

---

## 2) NEW FILES — SaveGame for exploration persistence

### `Source/FC/WorldMap/FCWorldMapSaveGame.h`

```cpp
// Copyright Iron Anchor Interactive. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/SaveGame.h"
#include "FCWorldMapSaveGame.generated.h"

UCLASS()
class FC_API UFCWorldMapSaveGame : public USaveGame
{
	GENERATED_BODY()

public:
	UPROPERTY()
	int32 Version = 1;

	// 65536 bytes for 256x256 (0/255) – simple and robust
	UPROPERTY()
	TArray<uint8> RevealMask;

	UPROPERTY()
	TArray<uint8> LandMask; // optional: store if you want (can be derived from texture)
};
```

### `Source/FC/WorldMap/FCWorldMapSaveGame.cpp`

```cpp
// Copyright Iron Anchor Interactive. All Rights Reserved.

#include "WorldMap/FCWorldMapSaveGame.h"
```

---

## 3) UPDATE — UFCExpeditionData (planning fields)

### Replace `Source/FC/Expedition/FCExpeditionData.h` with:

```cpp
// Copyright Iron Anchor Interactive. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "UObject/NoExportTypes.h"
#include "FCExpeditionData.generated.h"

UENUM(BlueprintType)
enum class EFCExpeditionStatus : uint8
{
	Planning    UMETA(DisplayName = "Planning"),
	InProgress  UMETA(DisplayName = "In Progress"),
	Completed   UMETA(DisplayName = "Completed"),
	Failed      UMETA(DisplayName = "Failed")
};

UCLASS(BlueprintType)
class FC_API UFCExpeditionData : public UObject
{
	GENERATED_BODY()

public:
	UPROPERTY(BlueprintReadWrite, Category = "Expedition")
	FString ExpeditionName;

	UPROPERTY(BlueprintReadWrite, Category = "Expedition")
	FString StartDate;

	UPROPERTY(BlueprintReadWrite, Category = "Expedition")
	FString TargetRegion;

	UPROPERTY(BlueprintReadWrite, Category = "Expedition")
	int32 StartingSupplies;

	UPROPERTY(BlueprintReadWrite, Category = "Expedition")
	EFCExpeditionStatus ExpeditionStatus;

	// --- World Map planning state (Week 4/5) ---
	UPROPERTY(BlueprintReadWrite, Category = "Expedition|WorldMap")
	int32 SelectedGridId = INDEX_NONE;

	UPROPERTY(BlueprintReadWrite, Category = "Expedition|WorldMap")
	int32 SelectedStartGridId = INDEX_NONE;

	UPROPERTY(BlueprintReadWrite, Category = "Expedition|WorldMap")
	int32 SelectedStartSubId = INDEX_NONE;

	UPROPERTY(BlueprintReadOnly, Category = "Expedition|WorldMap")
	int32 PreviewTargetGridId = INDEX_NONE;

	UPROPERTY(BlueprintReadOnly, Category = "Expedition|WorldMap")
	int32 PreviewTargetSubId = INDEX_NONE;

	// Global 0..65535 route (256x256)
	UPROPERTY(BlueprintReadOnly, Category = "Expedition|WorldMap")
	TArray<int32> PlannedRouteGlobalIds;

	UPROPERTY(BlueprintReadOnly, Category = "Expedition|WorldMap")
	int32 PlannedMoneyCost = 0;

	UPROPERTY(BlueprintReadOnly, Category = "Expedition|WorldMap")
	int32 PlannedRiskCost = 0;

	UFCExpeditionData();
};
```

### `Source/FC/Expedition/FCExpeditionData.cpp` (only small change)

```cpp
#include "Expedition/FCExpeditionData.h"

UFCExpeditionData::UFCExpeditionData()
	: ExpeditionName(TEXT("Unnamed Expedition"))
	, StartDate(TEXT("Day 1"))
	, TargetRegion(TEXT("Unknown"))
	, StartingSupplies(0)
	, ExpeditionStatus(EFCExpeditionStatus::Planning)
{
}
```

---

## 4) UPDATE — UFCExpeditionManager (Blueprint API + textures + timers + save/load)

### Replace `Source/FC/Expedition/FCExpeditionManager.h` with:

```cpp
#pragma once

#include "CoreMinimal.h"
#include "Subsystems/GameInstanceSubsystem.h"
#include "Logging/LogMacros.h"
#include "Expedition/FCExpeditionData.h"
#include "WorldMap/FCWorldMapExploration.h"
#include "FCExpeditionManager.generated.h"

DECLARE_LOG_CATEGORY_EXTERN(LogFCExpedition, Log, All);
DECLARE_LOG_CATEGORY_EXTERN(LogFCWorldMap, Log, All);

DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnExpeditionStateChanged, UFCExpeditionData*, ExpeditionData);
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnWorldMapChanged);

UCLASS()
class FC_API UFCExpeditionManager : public UGameInstanceSubsystem
{
	GENERATED_BODY()

public:
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	virtual void Deinitialize() override;

	UFUNCTION(BlueprintCallable, Category = "FC|Expedition")
	UFCExpeditionData* StartNewExpedition(const FString& ExpeditionName, int32 AllocatedSupplies);

	UFUNCTION(BlueprintCallable, Category = "FC|Expedition")
	UFCExpeditionData* GetCurrentExpedition() const { return CurrentExpedition; }

	UFUNCTION(BlueprintCallable, Category = "FC|Expedition")
	void EndExpedition(bool bSuccess);

	UFUNCTION(BlueprintCallable, Category = "FC|Expedition")
	bool IsExpeditionActive() const;

	UPROPERTY(BlueprintAssignable, Category = "FC|Expedition")
	FOnExpeditionStateChanged OnExpeditionStateChanged;

	// -----------------------------
	// World Map (UI-facing Blueprint API)
	// -----------------------------

	/** Fog reveal mask (256x256, PF_G8, 0/255) */
	UFUNCTION(BlueprintPure, Category = "FC|WorldMap")
	class UTexture2D* WorldMap_GetFogTexture() const { return FogTexture; }

	/** Route overlay mask (256x256, PF_G8, 0/255) */
	UFUNCTION(BlueprintPure, Category = "FC|WorldMap")
	class UTexture2D* WorldMap_GetRouteTexture() const { return RouteTexture; }

	/** Select a grid area on the map (currently only allows GridId 24). */
	UFUNCTION(BlueprintCallable, Category = "FC|WorldMap|Planning")
	bool WorldMap_SelectGridArea(int32 GridId);

	/** Build preview route and compute costs (office -> preview target). */
	UFUNCTION(BlueprintCallable, Category = "FC|WorldMap|Planning")
	bool WorldMap_BuildPreviewRoute();

	/** Animate route drawing: paint one subcell per step into RouteTexture. */
	UFUNCTION(BlueprintCallable, Category = "FC|WorldMap|Planning")
	void WorldMap_BeginRoutePreviewPaint(float StepSeconds = 0.03f);

	UFUNCTION(BlueprintCallable, Category = "FC|WorldMap|Planning")
	void WorldMap_ClearRoutePreview();

	/** Record exploration from overworld movement (call from convoy pawn). */
	UFUNCTION(BlueprintCallable, Category = "FC|WorldMap|Overworld")
	void WorldMap_RecordVisitedWorldLocation(const FVector& WorldLocation);

	/** Fired when reveal mask changed (optional for widgets that want a refresh ping). */
	UPROPERTY(BlueprintAssignable, Category = "FC|WorldMap")
	FOnWorldMapChanged OnWorldMapChanged;

	// --- Config (Editor) ---
	UPROPERTY(EditDefaultsOnly, Category = "FC|WorldMap|Terrain")
	TSoftObjectPtr<UTexture2D> LandMaskTexture;

	/** World bounds of overworld (used to map WorldLocation -> global 256x256) */
	UPROPERTY(EditDefaultsOnly, Category = "FC|WorldMap|Overworld")
	FVector2D OverworldWorldMin = FVector2D(-50000.f, -50000.f);

	UPROPERTY(EditDefaultsOnly, Category = "FC|WorldMap|Overworld")
	FVector2D OverworldWorldMax = FVector2D( 50000.f,  50000.f);

	// Debug / current milestone constants
	UPROPERTY(EditDefaultsOnly, Category = "FC|WorldMap|Milestone")
	int32 OfficeGridId = 8;

	UPROPERTY(EditDefaultsOnly, Category = "FC|WorldMap|Milestone")
	int32 OfficeSubId = 0;

	UPROPERTY(EditDefaultsOnly, Category = "FC|WorldMap|Milestone")
	int32 AvailableStartGridId = 24;

	UPROPERTY(EditDefaultsOnly, Category = "FC|WorldMap|Milestone")
	int32 AvailableStartSubId = 26;

	UPROPERTY(EditDefaultsOnly, Category = "FC|WorldMap|Milestone")
	int32 PreviewTargetGridId = 25;

	UPROPERTY(EditDefaultsOnly, Category = "FC|WorldMap|Milestone")
	int32 PreviewTargetSubId = 10;

private:
	UPROPERTY()
	TObjectPtr<UFCExpeditionData> CurrentExpedition;

	// --- World map runtime ---
	void WorldMap_InitOrLoad();
	void WorldMap_LoadLandMaskIfAvailable();
	void WorldMap_SyncFogTexture_Full();
	void WorldMap_UpdateFogPixel(int32 GlobalId);

	void WorldMap_StartAutosaveDebounced();
	void WorldMap_SaveNow();

	// Route paint
	void RoutePaint_Tick();
	FTimerHandle RoutePaintTimer;
	int32 RoutePaintIndex = 0;

	// Autosave debounce
	FTimerHandle AutosaveTimer;
	bool bExplorationDirty = false;

	// Textures + backing arrays
	UPROPERTY()
	TObjectPtr<UTexture2D> FogTexture;

	UPROPERTY()
	TObjectPtr<UTexture2D> RouteTexture;

	TArray<uint8> RouteMask; // 0/255, size 65536

	FFCWorldMapExploration WorldMap;

	// Save constants
	static constexpr const TCHAR* WorldMapSaveSlot = TEXT("FC_WorldMapExploration");
	static constexpr int32 WorldMapSaveUserIndex = 0;

	// Helpers
	UTexture2D* CreateMaskTexture256();
	void UpdateMaskTextureFull(UTexture2D* Texture, const TArray<uint8>& Data256);
	void UpdateMaskTexturePixel(UTexture2D* Texture, const TArray<uint8>& Data256, int32 GlobalId);

	void ComputeCostsForPath(const TArray<int32>& Path, int32& OutMoney, int32& OutRisk) const;
};
```

### Replace `Source/FC/Expedition/FCExpeditionManager.cpp` with:

```cpp
#include "Expedition/FCExpeditionManager.h"

#include "Kismet/GameplayStatics.h"
#include "Engine/Texture2D.h"
#include "Engine/World.h"
#include "WorldMap/FCWorldMapSaveGame.h"

DEFINE_LOG_CATEGORY(LogFCExpedition);
DEFINE_LOG_CATEGORY(LogFCWorldMap);

void UFCExpeditionManager::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);

	UE_LOG(LogFCExpedition, Log, TEXT("UFCExpeditionManager initialized"));
	CurrentExpedition = nullptr;

	WorldMap_InitOrLoad();

	// Create textures + buffers
	FogTexture = CreateMaskTexture256();
	RouteTexture = CreateMaskTexture256();

	RouteMask.Init(0, FFCWorldMapExploration::GlobalCount);

	WorldMap_SyncFogTexture_Full();
	UpdateMaskTextureFull(RouteTexture, RouteMask);
}

void UFCExpeditionManager::Deinitialize()
{
	// Final autosave
	if (bExplorationDirty)
	{
		WorldMap_SaveNow();
	}

	if (CurrentExpedition)
	{
		UE_LOG(LogFCExpedition, Warning, TEXT("Deinitialize called with active expedition: %s"),
			*CurrentExpedition->ExpeditionName);
	}

	Super::Deinitialize();
}

UFCExpeditionData* UFCExpeditionManager::StartNewExpedition(const FString& ExpeditionName, int32 AllocatedSupplies)
{
	if (CurrentExpedition)
	{
		UE_LOG(LogFCExpedition, Warning, TEXT("StartNewExpedition called while expedition already active: %s"),
			*CurrentExpedition->ExpeditionName);
		EndExpedition(false);
	}

	CurrentExpedition = NewObject<UFCExpeditionData>(this);
	CurrentExpedition->ExpeditionName = ExpeditionName;
	CurrentExpedition->StartingSupplies = AllocatedSupplies;
	CurrentExpedition->StartDate = FString::Printf(TEXT("Day %d"), 1);
	CurrentExpedition->TargetRegion = TEXT("Unknown Region");
	CurrentExpedition->ExpeditionStatus = EFCExpeditionStatus::InProgress;

	OnExpeditionStateChanged.Broadcast(CurrentExpedition);
	return CurrentExpedition;
}

void UFCExpeditionManager::EndExpedition(bool bSuccess)
{
	if (!CurrentExpedition)
	{
		UE_LOG(LogFCExpedition, Warning, TEXT("EndExpedition called with no active expedition"));
		return;
	}

	CurrentExpedition->ExpeditionStatus = bSuccess ? EFCExpeditionStatus::Completed : EFCExpeditionStatus::Failed;
	OnExpeditionStateChanged.Broadcast(CurrentExpedition);

	CurrentExpedition = nullptr;
}

bool UFCExpeditionManager::IsExpeditionActive() const
{
	return CurrentExpedition != nullptr &&
		   CurrentExpedition->ExpeditionStatus == EFCExpeditionStatus::InProgress;
}

// -----------------------------
// WorldMap init/load/save
// -----------------------------

void UFCExpeditionManager::WorldMap_InitOrLoad()
{
	UFCWorldMapSaveGame* Save = nullptr;

	if (UGameplayStatics::DoesSaveGameExist(WorldMapSaveSlot, WorldMapSaveUserIndex))
	{
		Save = Cast<UFCWorldMapSaveGame>(UGameplayStatics::LoadGameFromSlot(WorldMapSaveSlot, WorldMapSaveUserIndex));
	}

	if (Save && Save->RevealMask.Num() == FFCWorldMapExploration::GlobalCount)
	{
		WorldMap.GetRevealMaskMutable() = Save->RevealMask;

		if (Save->LandMask.Num() == FFCWorldMapExploration::GlobalCount)
		{
			WorldMap.SetLandMask(Save->LandMask);
		}
		else
		{
			WorldMap_LoadLandMaskIfAvailable();
		}

		UE_LOG(LogFCWorldMap, Log, TEXT("Loaded world map exploration from SaveGame."));
		return;
	}

	// New game init
	WorldMap.ApplyDefaultRevealedAreas_NewGame();
	WorldMap_LoadLandMaskIfAvailable();

	bExplorationDirty = true;
	WorldMap_SaveNow();

	UE_LOG(LogFCWorldMap, Log, TEXT("Initialized new world map exploration state."));
}

void UFCExpeditionManager::WorldMap_LoadLandMaskIfAvailable()
{
	TArray<uint8> NewLandMask;
	NewLandMask.Init(1, FFCWorldMapExploration::GlobalCount); // fallback all land

	UTexture2D* Tex = LandMaskTexture.LoadSynchronous();
	if (!Tex || !Tex->GetPlatformData() || Tex->GetPlatformData()->Mips.Num() == 0)
	{
		WorldMap.SetLandMask(NewLandMask);
		return;
	}

	// Expect 256x256 grayscale/rgba where >128 is land.
	// IMPORTANT: In editor set texture: NoMipmaps, sRGB off, and allow CPU access if needed.
	const int32 ExpectedW = FFCWorldMapExploration::GlobalSize;
	const int32 ExpectedH = FFCWorldMapExploration::GlobalSize;

	const FTexture2DMipMap& Mip = Tex->GetPlatformData()->Mips[0];
	if (Mip.SizeX != ExpectedW || Mip.SizeY != ExpectedH)
	{
		UE_LOG(LogFCWorldMap, Warning, TEXT("LandMaskTexture has wrong size (%dx%d). Expected 256x256."), Mip.SizeX, Mip.SizeY);
		WorldMap.SetLandMask(NewLandMask);
		return;
	}

	const void* DataPtr = Mip.BulkData.LockReadOnly();
	if (!DataPtr)
	{
		Mip.BulkData.Unlock();
		WorldMap.SetLandMask(NewLandMask);
		return;
	}

	// Try to interpret as bytes (common for grayscale). If your mask is RGBA, swap to reading first channel.
	const uint8* Bytes = static_cast<const uint8*>(DataPtr);

	// Heuristic: if grayscale, bytes == 65536. If RGBA, bytes == 262144.
	const int32 ByteCount = Mip.BulkData.GetBulkDataSize();
	if (ByteCount == (ExpectedW * ExpectedH))
	{
		for (int32 i = 0; i < FFCWorldMapExploration::GlobalCount; ++i)
		{
			NewLandMask[i] = (Bytes[i] > 128) ? 1 : 0;
		}
	}
	else if (ByteCount == (ExpectedW * ExpectedH * 4))
	{
		for (int32 i = 0; i < FFCWorldMapExploration::GlobalCount; ++i)
		{
			const uint8 R = Bytes[i * 4 + 0];
			NewLandMask[i] = (R > 128) ? 1 : 0;
		}
	}
	else
	{
		UE_LOG(LogFCWorldMap, Warning, TEXT("LandMaskTexture bulk size unexpected: %d bytes"), ByteCount);
	}

	Mip.BulkData.Unlock();
	WorldMap.SetLandMask(NewLandMask);
}

void UFCExpeditionManager::WorldMap_StartAutosaveDebounced()
{
	bExplorationDirty = true;

	// Debounce: reset timer
	if (UWorld* World = GetWorld())
	{
		World->GetTimerManager().ClearTimer(AutosaveTimer);
		World->GetTimerManager().SetTimer(AutosaveTimer, this, &UFCExpeditionManager::WorldMap_SaveNow, 0.75f, false);
	}
}

void UFCExpeditionManager::WorldMap_SaveNow()
{
	UFCWorldMapSaveGame* Save = Cast<UFCWorldMapSaveGame>(UGameplayStatics::CreateSaveGameObject(UFCWorldMapSaveGame::StaticClass()));
	if (!Save) return;

	Save->RevealMask = WorldMap.GetRevealMask();
	Save->LandMask   = WorldMap.GetLandMask();

	UGameplayStatics::SaveGameToSlot(Save, WorldMapSaveSlot, WorldMapSaveUserIndex);
	bExplorationDirty = false;

	UE_LOG(LogFCWorldMap, Verbose, TEXT("World map exploration saved."));
}

// -----------------------------
// Planning / selection
// -----------------------------

bool UFCExpeditionManager::WorldMap_SelectGridArea(int32 GridId)
{
	// Milestone: only allow selecting GridId 24 for now
	if (GridId != AvailableStartGridId)
	{
		UE_LOG(LogFCWorldMap, Verbose, TEXT("SelectGridArea rejected (GridId=%d). Only %d allowed for milestone."), GridId, AvailableStartGridId);
		return false;
	}

	// Ensure we have an expedition object to store planning state.
	if (!CurrentExpedition)
	{
		CurrentExpedition = NewObject<UFCExpeditionData>(this);
		CurrentExpedition->ExpeditionStatus = EFCExpeditionStatus::Planning;
	}

	CurrentExpedition->SelectedGridId = GridId;
	CurrentExpedition->SelectedStartGridId = AvailableStartGridId;
	CurrentExpedition->SelectedStartSubId  = AvailableStartSubId;

	CurrentExpedition->PreviewTargetGridId = PreviewTargetGridId;
	CurrentExpedition->PreviewTargetSubId  = PreviewTargetSubId;

	return WorldMap_BuildPreviewRoute();
}

bool UFCExpeditionManager::WorldMap_BuildPreviewRoute()
{
	if (!CurrentExpedition)
	{
		return false;
	}

	const int32 StartGlobal = FFCWorldMapExploration::AreaSubToGlobalId(OfficeGridId, OfficeSubId);
	const int32 GoalGlobal  = FFCWorldMapExploration::AreaSubToGlobalId(PreviewTargetGridId, PreviewTargetSubId);

	TArray<int32> Path;
	if (!WorldMap.FindShortestPath_BFS(StartGlobal, GoalGlobal, Path))
	{
		UE_LOG(LogFCWorldMap, Warning, TEXT("Failed to build preview route (Start=%d Goal=%d)."), StartGlobal, GoalGlobal);
		CurrentExpedition->PlannedRouteGlobalIds.Reset();
		CurrentExpedition->PlannedMoneyCost = 0;
		CurrentExpedition->PlannedRiskCost = 0;
		return false;
	}

	CurrentExpedition->PlannedRouteGlobalIds = Path;

	int32 Money = 0, Risk = 0;
	ComputeCostsForPath(Path, Money, Risk);
	CurrentExpedition->PlannedMoneyCost = Money;
	CurrentExpedition->PlannedRiskCost  = Risk;

	return true;
}

void UFCExpeditionManager::WorldMap_BeginRoutePreviewPaint(float StepSeconds)
{
	if (!CurrentExpedition || CurrentExpedition->PlannedRouteGlobalIds.Num() == 0)
	{
		return;
	}

	WorldMap_ClearRoutePreview();

	RoutePaintIndex = 0;

	if (UWorld* World = GetWorld())
	{
		World->GetTimerManager().ClearTimer(RoutePaintTimer);
		World->GetTimerManager().SetTimer(RoutePaintTimer, this, &UFCExpeditionManager::RoutePaint_Tick, StepSeconds, true);
	}
}

void UFCExpeditionManager::WorldMap_ClearRoutePreview()
{
	if (UWorld* World = GetWorld())
	{
		World->GetTimerManager().ClearTimer(RoutePaintTimer);
	}

	RouteMask.Init(0, FFCWorldMapExploration::GlobalCount);
	UpdateMaskTextureFull(RouteTexture, RouteMask);
}

void UFCExpeditionManager::RoutePaint_Tick()
{
	if (!CurrentExpedition)
	{
		WorldMap_ClearRoutePreview();
		return;
	}

	const TArray<int32>& Route = CurrentExpedition->PlannedRouteGlobalIds;
	if (RoutePaintIndex >= Route.Num())
	{
		WorldMap_ClearRoutePreview(); // stops timer + clears route
		return;
	}

	const int32 GlobalId = Route[RoutePaintIndex];
	if (FFCWorldMapExploration::IsValidGlobalId(GlobalId))
	{
		RouteMask[GlobalId] = 255;
		UpdateMaskTexturePixel(RouteTexture, RouteMask, GlobalId);
	}

	++RoutePaintIndex;
}

// -----------------------------
// Overworld exploration updates
// -----------------------------

void UFCExpeditionManager::WorldMap_RecordVisitedWorldLocation(const FVector& WorldLocation)
{
	const float MinX = OverworldWorldMin.X;
	const float MinY = OverworldWorldMin.Y;
	const float MaxX = OverworldWorldMax.X;
	const float MaxY = OverworldWorldMax.Y;

	const float DenX = FMath::Max(1.f, (MaxX - MinX));
	const float DenY = FMath::Max(1.f, (MaxY - MinY));

	const float U = FMath::Clamp((WorldLocation.X - MinX) / DenX, 0.f, 0.99999f);
	const float V = FMath::Clamp((WorldLocation.Y - MinY) / DenY, 0.f, 0.99999f);

	const int32 GX = FMath::FloorToInt(U * FFCWorldMapExploration::GlobalSize);
	const int32 GY = FMath::FloorToInt(V * FFCWorldMapExploration::GlobalSize);
	const int32 GlobalId = FFCWorldMapExploration::XYToGlobalId(GX, GY);

	const bool bChanged = WorldMap.SetRevealed_Global(GlobalId, true);
	if (bChanged)
	{
		WorldMap_UpdateFogPixel(GlobalId);
		WorldMap_StartAutosaveDebounced();
		OnWorldMapChanged.Broadcast();
	}
}

// -----------------------------
// Costs
// -----------------------------

void UFCExpeditionManager::ComputeCostsForPath(const TArray<int32>& Path, int32& OutMoney, int32& OutRisk) const
{
	OutMoney = 0;
	OutRisk = 0;

	// Cost per subgrid cell. You can choose whether to include the start cell:
	// Here: exclude Path[0] so "standing at origin" doesn't cost.
	for (int32 i = 1; i < Path.Num(); ++i)
	{
		const int32 Id = Path[i];

		const bool bIsWater = WorldMap.IsWater_Global(Id);
		const bool bWasRevealed = WorldMap.IsRevealed_Global(Id);

		// Money: water=3, land=1
		OutMoney += bIsWater ? 3 : 1;

		// Risk:
		// - water revealed 2, water unrevealed 3
		// - land revealed 1 (we treat land as 1 always for now; unrevealed land is not traversed except goal)
		if (bIsWater)
		{
			OutRisk += bWasRevealed ? 2 : 3;
		}
		else
		{
			OutRisk += 1;
		}
	}
}

// -----------------------------
// Texture helpers
// -----------------------------

UTexture2D* UFCExpeditionManager::CreateMaskTexture256()
{
	UTexture2D* Tex = UTexture2D::CreateTransient(FFCWorldMapExploration::GlobalSize, FFCWorldMapExploration::GlobalSize, PF_G8);
	if (!Tex) return nullptr;

	Tex->SRGB = false;
	Tex->CompressionSettings = TC_Grayscale;
	Tex->Filter = TF_Nearest;
	Tex->AddressX = TA_Clamp;
	Tex->AddressY = TA_Clamp;
	Tex->UpdateResource();
	return Tex;
}

void UFCExpeditionManager::UpdateMaskTextureFull(UTexture2D* Texture, const TArray<uint8>& Data256)
{
	if (!Texture || Data256.Num() != FFCWorldMapExploration::GlobalCount) return;

	FUpdateTextureRegion2D Region(0, 0, 0, 0, FFCWorldMapExploration::GlobalSize, FFCWorldMapExploration::GlobalSize);

	// UE5+ signature supports a cleanup lambda; we keep Data256 alive, so cleanup is empty.
	Texture->UpdateTextureRegions(
		0,
		1,
		&Region,
		FFCWorldMapExploration::GlobalSize * sizeof(uint8),
		sizeof(uint8),
		const_cast<uint8*>(Data256.GetData()),
		[](uint8* /*SrcData*/, const FUpdateTextureRegion2D* /*Regions*/) {}
	);
}

void UFCExpeditionManager::UpdateMaskTexturePixel(UTexture2D* Texture, const TArray<uint8>& Data256, int32 GlobalId)
{
	if (!Texture || Data256.Num() != FFCWorldMapExploration::GlobalCount) return;
	if (!FFCWorldMapExploration::IsValidGlobalId(GlobalId)) return;

	int32 X, Y;
	FFCWorldMapExploration::GlobalIdToXY(GlobalId, X, Y);

	FUpdateTextureRegion2D Region(X, Y, X, Y, 1, 1);
	Texture->UpdateTextureRegions(
		0,
		1,
		&Region,
		sizeof(uint8),
		sizeof(uint8),
		const_cast<uint8*>(&Data256[GlobalId]),
		[](uint8* /*SrcData*/, const FUpdateTextureRegion2D* /*Regions*/) {}
	);
}

void UFCExpeditionManager::WorldMap_SyncFogTexture_Full()
{
	UpdateMaskTextureFull(FogTexture, WorldMap.GetRevealMask());
}

void UFCExpeditionManager::WorldMap_UpdateFogPixel(int32 GlobalId)
{
	UpdateMaskTexturePixel(FogTexture, WorldMap.GetRevealMask(), GlobalId);
}
```

---

## 5) “If you need another file/manager” — Overworld hook (insert snippet)

Call this from your convoy pawn (tick or “moved far enough” event):

```cpp
#include "Expedition/FCExpeditionManager.h"

void AFCConvoyPawn::Tick(float DeltaSeconds)
{
	Super::Tick(DeltaSeconds);

	if (UGameInstance* GI = GetGameInstance())
	{
		if (UFCExpeditionManager* Exped = GI->GetSubsystem<UFCExpeditionManager>())
		{
			Exped->WorldMap_RecordVisitedWorldLocation(GetActorLocation());
		}
	}
}
```

---

## 6) UMG hookup (quick wiring)

- Fog overlay material: `ExplorationTexture` = `WorldMap_GetFogTexture()`
- Route overlay material: `RouteTexture` = `WorldMap_GetRouteTexture()`
- When player clicks Grid 24:

  - `WorldMap_SelectGridArea(24)` (this also builds route + costs)
  - `WorldMap_BeginRoutePreviewPaint()`

---

If you paste these in and you want the **“grid id bottom-left = 0”** to be reflected in UI click coordinates too, tell me how you currently map `MousePosition -> GridId`, and I’ll give you the exact conversion (it’s usually just flipping Y).